using afSizzle
using xml

// TODO: expose the XElems
** Represents a number of HTML elements as returned from `BedClient` select CSS methods.
class Element {
	
	// ---- Standard Methods -------------------------------------------------------------------------------------------
	
	** Returns 'true' if this element exists.
	Bool exists() {
		!findElems.isEmpty
	}
	
	** Returns 'true' if this element does not exists.
	Bool doesNotExist() {
		findElems.isEmpty
	}
	
	** Returns the text content of this element and it's child elements.
	Str text() {
		getText(findElem)
	}

	** Returns the markup generated by this node, including the element itself. 
	Str markup() {
		getMarkup(findElem)
	}

	** Returns the markup generated by the children of this node. 
	Str childMarkup() {
		getChildMarkup(findElem)
	}

	@Operator
	Str? getAttribute(Str name) {
		findElem.attr(name, false).val
	}

	@Operator
	This getAtIndex(Int index) {
		elems := findElems
		if (index >= elems.size)
			fail("CSS not found: ")
		return newElement(findElems[index], css, index)
	}

	** Returns the number of elements found by the selector
	Int size() {
		findElems.size
	}

	** Finds elements *inside* this element.
	Element find(Str cssSelector) {
		elems := SizzleDoc(findElem).select(cssSelector)
		return newElements(elems, css + " " + cssSelector)		
	}
	
	** Return all elements as a list.
	Element[] list() {
		findElems.map |elem, i| { newElement(elem, css, (index?:0) + i) }
	}
	
	
	
	// ---- Verify Methods ---------------------------------------------------------------------------------------------
	
	Void verifyExists() {
		verifyTrue(exists, "CSS does NOT exist: ")
	}
	
	Void verifyDoesNotExists() {
		verifyTrue(doesNotExist, "CSS DOES exist: ")
	}
	
	Void verifyText(Obj expected) {
		verifyEq(text, expected)
	}

	Void verifyTextContains(Obj contains) {
		verifyTrue(text.trim.lower.contains(contains.toStr.trim.lower), "Text does NOT contain '${contains}': ")
	}
	
	Void verifyTextIsEmpty() {
		verifyTrue(text.isEmpty, "Text is NOT empty: ")
	}
	
	Void verifyChildMarkup(Obj expected) {
		verifyEq(childMarkup, expected)
	}
	
	Void verifyMarkup(Obj expected) {
		verifyEq(markup, expected)
	}
	
	Void verifyAttrExists(Str attrName) {
		verifyTrue(findElem.attr(attrName, false) != null, "Attribute '${attrName}' does NOT exist: ")
	}

	Void verifyAttrEq(Str attrName, Obj expected) {
		verifyAttrExists(attrName)
		verifyEq(findElem.attr(attrName).val, expected)
	}
	
	Void verifySize(Int expectedSize) {
		verifyEq(size.toStr, expectedSize)
	}
	
	
	
	// ---- Protected Methods ------------------------------------------------------------------------------------------
	
	private XElem[]?	elems
	private const Str		css
	// TODO: convert index to :nth-child with CSS3 & kill elems field
	private const Int?		index
	
	new make(Str cssSelector) {
		this.elems 	= null
		this.css 	= cssSelector
		this.index	= null		
	}
	
	protected new makeInternal(XElem[] elems, Str css := "", Int? index := null) {
		indx := (index == null) ? Str.defVal : " at [${index}]"
		this.elems 	= elems
		this.css 	= css + indx
		this.index	= index
	}

	virtual protected This newElement(XElem elem, Str css := "", Int? index := null) {
		Element([elem], css, index)
	}

	virtual protected This newElements(XElem[] elems, Str css := "", Int? index := null) {
		Element(elems, css, index)
	}
	
	virtual protected Void verifyTrue(Bool condition, Str msg) {
		Verify().verify(condition, msg + toStr)
	}
	
	virtual protected Void verifyEq(Str actual, Obj expected) {
		if (actual.trim.lower != expected.toStr.trim.lower)
			Verify().verifyEq(actual, expected)
	}

	virtual protected Void fail(Str msg) {
		Verify().fail(msg + toStr)
	}


	
	// ---- Private Methods --------------------------------------------------------------------------------------------
	
	private XElem findElem() {
		elems := findElems
		if (elems.size != 1)
			fail("CSS does not exist: ")
		return elems.first
	}

	private XElem[] findElems() {
		(elems != null) ? elems : BedClient.getThreadedClient.selectCss(css)
	}

	private Str getMarkup(XElem elem) {
		elem.writeToStr
	}

	private Str getChildMarkup(XElem elem) {
		elem.children.map |XNode node->Str| { node.writeToStr }.join
	}

	private Str getText(XNode node) {
		if (node is XText)
			return ((XText) node).val
		if (node is XElem)
			return ((XElem) node).children.map { getText(it) }.join
		return Str.defVal
	}

	override Str toStr() {
		return css + "\n" + findElems.map { getChildMarkup(it) }.join("\n")
	}
}

internal class Verify : Test {}
